#summary Description of the fundamental basis of the graph generation.
#labels theory

<wiki:toc max_depth="2" />

= Overview =

Generating a random graph that is shaped vaguely like a plausible genomic interaction network is a hard problem because it is very poorly specified. Mathematically, what "looks like an interaction network"? The properties of appropriate graphs are mostly subjective, hard to quantify, and most plausible guesses turn out to be wrong.

While there is a wide variety of canned random graph generation algorithms, the graphs they produce are generally inappropriate, due to having the wrong shape. Algorithms that are carefully tuned to make guarantees about uniform distribution of graph shapes are, categorically, not optimized for this space.

A desperate attempt to get a working algorithm by computationally simulating the process of drawing circles on a sheet of paper and drawing edges between them and calling it a graph turns out to be the most effective algorithm of many tried, even though this causes what would ideally be a completely abstract graph algorithm to ricochet off computational geometry in the process.

= Approach =

The algorithm that became the Spiral Point Distribution came after several unsuccessful designs for an algorithm defined purely by abstract graph theory. With no mathematical definition of a "good" graph forthcoming, and no success in defining one, developing an algorithm was purely a guessing game.

With no success in abstract algorithms, I contemplated how, would, by hand, draw "something that looks like an interaction network." I came up with a sequence of steps like this:

  # Draw circles in sort of cluster-y chain-like ways.
  # Draw arrows between them that follow those paths and put crosslinks within clusters.
  # Don't create any cycles.

This is very much an "I know it when I see it" thing. But if attempts to mathematically create a graph with similar properties weren't working, what if I wrote a program to do exactly this?

Now I had three different problems to solve, one of which was very easy- once I had the general shape right, making sure the graph was acyclic would be the simplest. What would put the nodes "in the right spot", and "draw edges" between them?

==Placing points==

Since I'm abstracting the problem to something where nodes have a _position_, then the most sensible way to represent one is a two-dimensional point. To assign them in random, but cluster-forming ways that also tend to form chains, I opted to place them in a circular pattern with a steadily-increasing radius. This also solved the "acyclic graph" problem: make all edges point "outwards" and no cycles can form.

To cause clusters, instead of placing points randomly on the circle, I initially chose random angles at the current radius, found the geometrically nearest points, and adjusted the angle to be the average of the random angle and the points that wound up nearest. This approach leads to loose, meandering, branching clusters, which is exactly the pattern desired.

==Drawing lines==

A Delaunay triangulation provides a good start at connecting the nodes together. However, this provides too many edges; points that are apparently part of different groups and should be treated as such are bound together, since they are still "next to" each other in terms of region adjacency.

Triangulating the region and then trimming out "long" edges was the order of the day. The Delaunay triangulation was converted to a directed graph with edges pointing outwards from the center, and edge weights equal to the Euclidean distance between nodes. This is where GraphPruning algorithms begin: finding edges that "should be" trimmed off the graph.

Several pruning strategies have been tried, and three of them have been found to work acceptably; there's room for improvement in pruners, but the foundation seems sound.

= Algorithm =

The Spiral Point Distribution algorithm plots points in polar coordinates (converting between turns and radians because this actually results in the most practical function interface), but stores them in rectangular (Cartesian) coordinates for ease of nearest-neighbor and Euclidean distance calculation. It eventually outputs the set of points; the triangulation and conversion to a graph technically happens in a different module, although it's closely related.

==Inputs==

The Spiral Point Distribution takes six parameters. It is not a "true" mathematical function, since its behavior is randomized; calls with identical parameters will almost never produce identical results.

  * *_nPoints_ --* Total number of points to generate (including seeds).
  * *_nSeeds_ --* Number of points to place in the center circle, which will become the 0-ary "generator" nodes of the graph in the output
  * *_r0_ --* Radius of the starting circle around which the seeds are evenly placed
  * *_delta_ --* Amount to increase the radius by for each point
  * *_spread_ --* Range, measured in turns (fractions of a full circle), for random generation of next angle
  * *_z_ --* Number of points to grab for clustering behavior


==Output==

A list of points, represented as 2-tuples of float (representing x,y coordinates).

The first _nSeeds_ of these points are arranged in a circle around the origin (0, 0), and the remainder of the list is in strictly increasing radius from the origin. The points will follow the clustered pattern typical of this algorithm.

==Method==

With variable names as listed above for inputs, the exact algorithm is as follows, in pseudocode:

{{{
function spiralPointDistribution:
    #sanity checks
    assert nSeeds >= nPoints
    warn if nSeeds == nPoints

    ret = list containing nSeeds points arranged in an r0-radius circle around the origin

    theta = 0
    r = r0

    while (length of ret) < nPoints:
        increment r by delta
        add a random angle between 0 and spread to theta
        calculate Cartesian coordinates (x, y) from polar coordinates (r, theta)
        closestZ = the closest z points in ret to (x, y)
        allThetas = list of all angles in closestZ
        append theta to allThetas
        theta = mean(allThetas)
        recalculate (x, y) from (r, theta) #with theta updated
        append (x, y) to ret
    end while

    return ret
end function
}}}

Note that ret is storing values in Cartesian space, although many of the operations are polar. A strong argument can be made for storing ret as (x, y, theta) inside the function, then returning a list made from the (x, y) of ret to avoid several avoidable Cartesian-to-polar conversions. This is an implementation detail and can be revisited at any time.

= Weaknesses =
= Tweakable Knobs =